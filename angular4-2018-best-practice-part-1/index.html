<!DOCTYPE html>



 <html class="no-js" lang="en"> 
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Hello from star-d46.. Anybody out there ?">

	<title>Daghan Gunay&#39;s Blog: Home</title>

	<link rel="canonical" href="https://d46.github.io/blog/angular4-2018-best-practice-part-1/">
	

	
<meta property="twitter:account_id" content="285428413" />
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@jessfraz">
<meta name="twitter:creator" content="@jessfraz">
<meta name="twitter:title" content="Daghan Gunay&#39;s Blog: Home">
<meta name="twitter:description" content="Hello from star-d46.. Anybody out there ?">
<meta name="twitter:image:src" content="/img/share.png">
<meta name="twitter:image:width" content="500">
<meta name="twitter:image:height" content="500">
<meta name="twitter:domain" content="blog.jessfraz.com">


<meta property="og:title" content="Angular4 Best Practices Part 1"/>
<meta property="og:Section" content="website"/>
<meta property="og:url" content="https://d46.github.io/blog/angular4-2018-best-practice-part-1/"/>
<meta property="og:image" content="/img/share.png"/>
<meta property="og:site_name" content="Daghan Gunay&#39;s Blog"/>
<meta property="fb:admins" content="1018260045"/>
<meta property="og:description" content="Hello from star-d46.. Anybody out there ?"/>


	<link rel="shortcut icon" href="https://d46.github.io/blog/favicon.ico">

	<link rel="stylesheet" href="https://d46.github.io/blog/css/main.css" />
	<script src="https://d46.github.io/blog/js/lib/modernizr-2.6.2.min.js"></script>
</head>
<body onload="doPrettyPrint()">

<header>
	<nav>
		<ul class="main">
			<li><a href="https://d46.github.io/blog">Daghan Gunay&#39;s Blog</a></li>
		</ul>
		<ul class="social">
			
			<li>
				<a class="fa fa-github" href="https://github.com/d46" target="_blank"></a>
			</li>
		</ul>
	</nav>
</header>



<div class="container single">
	<article>
		<h2>Angular4 Best Practices Part 1</h2>
		<div class="time">Tuesday, April 10, 2018</div>
		

<p>I will explain the best practices for Angular in nowadays. We will also introduce of angular packages which are store, effects, router-store, store-devtools, entity, schematics.</p>

<h1 id="ngrx-schematics">@ngrx/schematics</h1>

<p>It provides blueprints for generating files when building out feature areas using NgRx like
Action,
Container,
Effect,
Entity,
Feature,
Reducer and
Store.</p>

<p>At the beginning, create basic angular app with the following orders</p>

<pre><code class="language-javascript"># First, create an angular app
ng new ngrx-best-practices-2018
cd ngrx-store-playground

// Install the schematics
yarn add @ngrx/schematics --dev

// Install the NgRx dependencies.
yarn add @ngrx/{store,effects,entity,store-devtools}
</code></pre>

<h1 id="ngrx-store">@ngrx/store</h1>

<p>It&rsquo;s a store management library for ngrx but first, we have to get the idea behind on it.</p>

<h2 id="what-are-these-states">What are these states?</h2>

<p>States come from state pattern.</p>

<p>There are three subjects we should know about this.</p>

<p>First is store, giant object or final data of our application.</p>

<p>Second is state, particularly action/status of the application. For example, the car on tier 2 means; The car&rsquo;s state for the tier is on two. In other words, the application tier is 2 (Application=Car). The car&rsquo;s state for the window is open/true.</p>

<p>Third are reducers, bunch of functions/methods help to change the states on the store.</p>

<p>Let&rsquo;s explain with some hack.</p>

<pre><code class="language-javascript">// It's a super basic store
const data = { tier: 1, window: false };

// Reducers 
const increseTier = (data) =&gt; data = {
 ...data,
 tier: ++data.tier
} // Object spread

const toggleWindow = (data) =&gt; data = {
 ...data,
 window: !data.window
} // Object spread

//State changes
data = increseTier(data); // { tier: 2, window: false }

//State changes
data = toggleWindow(data); // { tier: 1, window: true }

</code></pre>

<p>Let&rsquo;s change this approach to little bit more handy</p>

<pre><code class="language-javascript">// It's a super basic store
const data = { tier: 1, window: false };

// Reducers 
const reducers = (data, type) =&gt; {
  
  const increseTier = (data) =&gt; data = {
   ...data,
   tier: ++data.tier
  } // Object spread

  const toggleWindow = (data) =&gt; data = {
   ...data,
   window: !data.window
  } // Object spread

  switch(type) { 
    case 'increseTier':
     return increseTier(data);
    case 'toggleWindow':
     return toggleWindow(data);
  }

  return data;
}

// State changes
reducers(data, 'increseTier'); // { tier: 2, window: false }

// State changes
reducers(data,'toggleWindow'); // { tier: 1, window: true }


</code></pre>

<p>Calling reducers with the required parameters which are data(data=store) and action type(&lsquo;increaseTier&rsquo;) occur to alteration on the store. As such, the origin of mutation starts and depends on just two variable.</p>

<h2 id="simple-ngrx-store-usage">Simple ngrx/store usage</h2>

<pre><code class="language-sh"># Add ngrx store library
yarn add @ngrx/store
</code></pre>

<p>Every module has own store</p>

<pre><code class="language-sh"># Generate store for app-module
ng generate store State --store --module app.module.ts --collection @ngrx/schematics
</code></pre>

<p>Schematics are allow to create state module files. Along with, injects required lines into the app.module</p>

<pre><code class="language-javascript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';


import { AppComponent } from './app.component';
import { StoreModule } from '@ngrx/store';
import { reducers, metaReducers } from './reducers';
import { StoreDevtoolsModule } from '@ngrx/store-devtools';
import { environment } from '../environments/environment';


@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    // Here   &lt;-------
    StoreModule.forRoot(reducers),
    !environment.production ? StoreDevtoolsModule.instrument() : []
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

</code></pre>

<p>Open reducers/index.ts which we generated.</p>

<pre><code class="language-javascript">import {
  ActionReducer,
  ActionReducerMap,
  createFeatureSelector,
  createSelector,
  MetaReducer
} from '@ngrx/store';
import { environment } from '../../environments/environment';

export interface State {

}

export const reducers: ActionReducerMap&lt;State&gt; = {

};


export const metaReducers: MetaReducer&lt;State&gt;[] = !environment.production ? [] : [];
</code></pre>

<p>We will implement the state pattern which we created on the upper section but in a way of angular store.
Starting over reducers, ActionReducerMap and MetaReducer are two variables. Along with to make a mutation for store.</p>

<h2 id="define-a-count-into-the-state-interface">Define a count into the State interface</h2>

<pre><code class="language-javascript">export interface State {
  count: number
}
</code></pre>

<p>Remember, on the upper section of car example, reducer usage was like this.</p>

<pre><code class="language-javascript">// Past example

// Reducers 
const reducers = (data, type) =&gt; {
  
  const increseTier = (data) =&gt; data = {
   ...data,
   tier: ++data.tier
  } // Object spread
...
</code></pre>

<p>In conclusion, We will define function as like as increaseTier. Afterwards, We will add this function to reducer container like ActionReducerMap.</p>

<h2 id="define-a-reducer-for-count">Define a reducer for count</h2>

<pre><code class="language-javascript">function reducer (count = 0): number {
  return count;
}
</code></pre>

<h2 id="define-a-actionreducermap">Define a ActionReducerMap</h2>

<p>This is the basic state and whole store.</p>

<pre><code class="language-javascript">export const reducers: ActionReducerMap&lt;State&gt; = {
  count: reducer
};
</code></pre>

<p>On calling state it returns..</p>

<pre><code class="language-javascript">{
 count: function reducer(count = 0):number {
  return count
 }
}
// And It looks like this ---&gt;

{
 count: 0
}
</code></pre>

<h2 id="reducers-index-ts">reducers/index.ts</h2>

<pre><code class="language-javascript">import {
  ActionReducer,
  ActionReducerMap,
  createFeatureSelector,
  createSelector,
  MetaReducer
} from '@ngrx/store';
import { environment } from '../../environments/environment';

export interface State {
  count: number
}

function reducer (state = 0): number {
  return state;
}

export const reducers: ActionReducerMap&lt;State&gt; = {
  count: reducer
};

export const metaReducers: MetaReducer&lt;State&gt;[] = !environment.production ? [] : [];
</code></pre>

<h2 id="observable">Observable</h2>

<p>In the app-component file, we are using Observable to make a pipe callback and fetch the data by this callback from the store. Observable is works like a stream in any other additional languages. It is allowing us to chain more than one event instead of Promise chains. Observable also has the advantage over Promise to be cancelable.</p>

<h2 id="selector">Selector</h2>

<p>Use select operator to select slice(s) of state. It is a practical solution for the confusion of banana jungle problem. On the module, we update the current state. Afterwards, we have to find the related state in the whole store of every reducer. On conclude, using selectors prevent this repetition.</p>

<h2 id="app-component-ts">app.component.ts</h2>

<pre><code class="language-javascript">import { Component } from '@angular/core';
import { Store, select, createSelector } from '@ngrx/store';
import { Observable } from 'rxjs';
import { State } from './reducers'

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})

export class AppComponent {
  title = 'app';
  //Variable as Observable
  count$: Observable&lt;number&gt;;
  
  constructor(private store: Store&lt;State&gt;) {
    // Selector
    this.count$ = store.pipe(select('count'));
  }
}
</code></pre>

<h2 id="app-component-html">app.component.html</h2>

<p>We use async pipe for resolve promise or observable objects.</p>

<pre><code class="language-html">&lt;div&gt;Current Count: {{ count$ | async }}&lt;/div&gt;
</code></pre>

<p>Now we have store with initialState.</p>

<pre><code class="language-sh">ng serve -o
</code></pre>

<p><img src="https://d46.github.io/blog/img/angular4-2018-best-practice-001.png" alt="count0" /></p>

<p>In that part, we used shematics to built a tiny store. Next chapter, We are going to use other packages.</p>

	</article>
</div>

	<footer>&copy; Theme by Jessie Frazelle 2016
		<a class="pull-right" href="https://github.com/jessfraz/blog" target="_blank">Theme by @jessfraz</a>
	</footer>

	<script src="https://d46.github.io/blog/js/prettify/prettify.js"></script>

    <script>
        function doPrettyPrint(){
            pres=document.getElementsByTagName('pre');
            for (i=0; i < pres.length; i++) {
                pres[i].className+=" prettyprint";
            }
            prettyPrint();
        }
    </script>

	
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-69892600-2"></script>
	<script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-69892600-2');
	</script>

	</body>
</html>
